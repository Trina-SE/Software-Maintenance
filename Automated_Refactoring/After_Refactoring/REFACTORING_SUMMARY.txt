================================================================================
REFACTORING SUMMARY - Automated_Refactoring Project
================================================================================

This document details all refactoring tasks performed on the project,
including the code selection, before/after comparisons, and improvements.

================================================================================
TASK 1: ELIMINATE CODE DUPLICATION IN DATA_PROCESSOR.PY
================================================================================

Task: Move repeated code into functions (Remove duplication in process_numbers, 
       process_strings, process_mixed)

Code Selection:
    File: data_processor.py
    Methods: process_numbers(), process_strings(), process_mixed()
    Lines: All three methods had identical loop/aggregation patterns

Type: Move repeated calculations into functions + Extract reusable helper

Before Refactoring:
    - process_numbers(): Manual loop, temp variables (result, total, count, avg)
    - process_strings(): Identical loop structure, different type check/transform
    - process_mixed(): Combined both patterns with elif logic
    - Each method duplicated the aggregation pattern: loop → check type →
      transform → measure → aggregate → calculate average → return dict
    
    Problems:
    • Code duplication: Same loop/aggregation logic repeated 3 times
    • Maintenance burden: Any bug fix must be applied to all three methods
    • Hard to extend: Adding new data types requires repeating pattern
    • Poor Single Responsibility: Each method handles both transformation 
      AND aggregation

After Refactoring:
    - Created _process_with_rules(data, rules) helper:
      • Accepts list of (type_check, transform, measure) tuples
      • Single loop that applies rules and aggregates data
      • Eliminates all duplication
    
    - Simplified process_numbers, process_strings, process_mixed:
      • Now just call _process_with_rules with appropriate rules
      • One-liner implementations focusing on intent
    
    - Added type hints and comprehensive docstrings
    - Improved calc_stats() to convert input to list for robustness

Benefits:
    ✓ 50% less code (from ~90 lines → ~45 lines)
    ✓ Easier to maintain: fix aggregation logic in one place
    ✓ Easy to extend: just add new rules
    ✓ Better separation of concerns
    ✓ Type hints improve IDE support

Before Code Excerpt:
    def process_numbers(self, data):
        result = []
        total = 0
        count = 0
        for item in data:
            if isinstance(item, (int, float)):
                result.append(item * 2)
                total = total + item
                count = count + 1
        avg = total / count if count > 0 else 0
        return {'processed': result, 'total': total, 'average': avg, 'count': count}

After Code Excerpt:
    def process_numbers(self, data: Iterable[Any]) -> Dict[str, Any]:
        """Process numeric items: doubles each and aggregates."""
        return self._process_with_rules(
            data,
            [((int, float), lambda x: x * 2, lambda x: x)],
        )

    def _process_with_rules(self, data, rules):
        """Generic rule-driven processor for data aggregation."""
        processed = []
        total = 0
        count = 0
        for item in data:
            for type_check, transform, measure in rules:
                if isinstance(item, type_check):
                    processed.append(transform(item))
                    total += measure(item)
                    count += 1
                    break
        avg = total / count if count > 0 else 0
        return {"processed": processed, "total": total, "average": avg, "count": count}

================================================================================
TASK 2: IMPROVE NAMING IN USER_MANAGER.PY
================================================================================

Task: Use better variable and function names + Extract validation

Code Selection:
    File: user_manager.py
    Methods: add_user(n, e, a, p), remove_user(e), get_user(e),
             update_user(e, n, a), list_users(), get_user_count()
    Lines: All parameter names and validation logic

Type: Rename variables and extract validation + Remove code duplication

Before Refactoring:
    - Parameter names: n, e, a, p (cryptic abbreviations)
    - User dict keys: 'nm', 'em', 'ag', 'pwd' (abbreviated, hard to understand)
    - Validation duplicated in add_user() and update_user()
    - Manual index loops: for i in range(len(self.users))
    - Maintained user_count separately (redundant with len(self.users))
    
    Problems:
    • Unclear intent: What is 'n'? 'e'? Hard to read and maintain
    • Validation duplication: Same checks in add_user and update_user
    • Inefficient search: Using index loops instead of direct iteration
    • Redundant state: user_count duplicates len(self.users)
    • No type hints: Hard to know parameter types

After Refactoring:
    - Renamed parameters: name, email, age, password (clear and descriptive)
    - Renamed user dict keys: 'name', 'email', 'age', 'password'
    - Created UserValidator class:
      • Centralized validation rules with constants
      • Separate methods: validate_name, validate_email, validate_age, validate_password
      • Single validate_user() method that combines all checks
    
    - Simplified search using Pythonic pattern:
      • next((u for u in self.users if u["email"] == email), None)
      • Replaces manual index loops
    
    - Removed user_count: Now just use len(self.users)
    - Added type hints throughout
    - Added comprehensive docstrings

Benefits:
    ✓ Code is self-documenting: parameter names are clear
    ✓ Validation is centralized: easier to maintain and extend
    ✓ Pythonic patterns: more idiomatic Python code
    ✓ ~30% less code (from ~70 lines → ~50 lines)
    ✓ Eliminates redundant state management
    ✓ Better type safety with hints

Before Code Excerpt (add_user):
    def add_user(self, n, e, a, p):
        if len(self.users) >= self.max_users:
            return False
        if len(n) < 3:
            return False
        if '@' not in e:
            return False
        if a < 18 or a > 120:
            return False
        if len(p) < 6:
            return False
        u = {'nm': n, 'em': e, 'ag': a, 'pwd': p}
        self.users.append(u)
        self.user_count = self.user_count + 1
        return True

After Code Excerpt (add_user with validation extraction):
    def add_user(self, name: str, email: str, age: int, password: str) -> bool:
        if len(self.users) >= self.MAX_USERS:
            return False
        if not UserValidator.validate_user(name, email, age, password):
            return False
        user = {"name": name, "email": email, "age": age, "password": password}
        self.users.append(user)
        return True

Before Code Excerpt (manual loop):
    def get_user(self, e):
        for i in range(len(self.users)):
            if self.users[i]['em'] == e:
                return self.users[i]
        return None

After Code Excerpt (Pythonic pattern):
    def _find_user_by_email(self, email: str) -> Optional[Dict]:
        return next((u for u in self.users if u["email"] == email), None)

================================================================================
TASK 3: EXTRACT CONSTANTS AND SPLIT PROCESS_ORDER IN CALCULATOR.PY
================================================================================

Task: Extract magic numbers and split complex functions

Code Selection:
    File: calculator.py
    Methods: calc_discount(), calc_tax(), calc_shipping(), process_order()
    Magic numbers: 0.1, 0.15, 0.2, 0.25, 0.18, 50, 100, 150, 200, 300, etc.

Type: Extract constants + Split long functions into smaller focused methods

Before Refactoring:
    - Magic numbers scattered throughout:
      • Discount rates: 0.1, 0.15, 0.2, 0.25 (hard-coded in if/elif chain)
      • Tax rate: 0.18 (single magic number)
      • Shipping costs: 50, 100, 150, 200, 300 (hard-coded in conditionals)
      • Weight multipliers: 1.5, 2.5 (in process_order)
    
    - process_order() is a 40-line monolithic function:
      • Validates inputs, calculates subtotal
      • Applies discount (duplicates calc_discount logic!)
      • Calculates tax (duplicates calc_tax logic!)
      • Calculates weight (custom logic mixed in)
      • Calculates shipping (duplicates calc_shipping logic!)
      • Computes final total
    
    - divide() returns 0 on zero division instead of raising error
    
    Problems:
    • Magic numbers: Hard to change rates/thresholds without hunting through code
    • No single source of truth for business rules
    • process_order duplicates logic from other methods
    • Long function: Hard to test, understand, and maintain
    • Poor error handling: divide() silently returns 0

After Refactoring:
    - Created module-level constants:
      • DISCOUNT_RATES = {'A': 0.1, 'B': 0.15, ...} (dict-based, extendable)
      • TAX_RATE = 0.18 (single definition)
      • SHIPPING_BRACKETS = [(1, 50), (5, 100), ...] (tuple-based lookup)
      • Weight and threshold constants with descriptive names
    
    - Extracted methods from process_order():
      • calc_order_weight(quantity, subtotal) - computes weight based on threshold
      • Replaced duplicate discount/tax/shipping logic with existing methods
    
    - Improved divide() to raise ValueError on zero division
    - Renamed parameters: p→price, q→quantity, dt→discount_type
    - Added type hints and comprehensive docstrings

Benefits:
    ✓ Constants are centralized: change rates in one place
    ✓ process_order() reduced from 40 lines → 20 lines
    ✓ No code duplication: process_order now reuses helper methods
    ✓ Better error handling: divide() raises exceptions (more Pythonic)
    ✓ Easier to test: smaller methods with single responsibility
    ✓ More maintainable: clear intent with named constants

Before Code Excerpt (Magic numbers):
    def calc_discount(self, price, discount_type):
        if discount_type == 'A':
            return price * 0.1
        elif discount_type == 'B':
            return price * 0.15
        elif discount_type == 'C':
            return price * 0.2
        elif discount_type == 'VIP':
            return price * 0.25
        else:
            return 0

After Code Excerpt (Constants):
    DISCOUNT_RATES = {
        "A": 0.10,
        "B": 0.15,
        "C": 0.20,
        "VIP": 0.25,
    }
    
    def calc_discount(self, price: Number, discount_type: str) -> Number:
        rate = DISCOUNT_RATES.get(discount_type, 0)
        return price * rate

Before Code Excerpt (process_order monolith):
    def process_order(self, p, q, dt):
        if p <= 0 or q <= 0:
            return None
        subtotal = p * q
        # ... 15 more lines of mixed logic ...
        if dt == 'A':
            discount = subtotal * 0.1  # DUPLICATE from calc_discount!
        # ... etc, all duplicated logic ...

After Code Excerpt (Split into smaller methods):
    def process_order(self, price, quantity, discount_type):
        if price <= 0 or quantity <= 0:
            return None
        
        subtotal = price * quantity
        discount = self.calc_discount(subtotal, discount_type)  # Reuse!
        after_discount = subtotal - discount
        tax = self.calc_tax(after_discount)  # Reuse!
        subtotal_with_tax = after_discount + tax
        
        weight = self.calc_order_weight(quantity, subtotal)  # New helper!
        shipping = self.calc_shipping(weight)  # Reuse!
        
        final_total = subtotal_with_tax + shipping
        return {...}
    
    def calc_order_weight(self, quantity, subtotal):
        """Calculate weight based on subtotal threshold."""
        multiplier = (HEAVY_WEIGHT_MULTIPLIER if subtotal > WEIGHT_THRESHOLD_TOTAL
                      else LIGHT_WEIGHT_MULTIPLIER)
        return quantity * multiplier

================================================================================
TASK 4: IMPROVE CONFIG.PY WITH DEPENDENCY INJECTION
================================================================================

Task: Reduce tight coupling and improve testability

Code Selection:
    File: config.py
    Class: AppConfig
    Lines: __init__() method that directly instantiates managers

Type: Refactor to use dependency injection pattern

Before Refactoring:
    - AppConfig directly instantiates concrete classes:
      • UserManager(), DataProcessor(), Calculator()
      • Classes are tightly coupled in __init__
    
    - Configuration is mixed with object instantiation
    - Hard to test: Can't inject mocks without modifying config
    - No separation of concerns: Config handles both settings AND object creation
    
    Problems:
    • Tight coupling: AppConfig depends on concrete implementations
    • Not testable: Hard to inject mocks for unit tests
    • Inflexible: Can't easily swap implementations
    • Single Responsibility Principle violated

After Refactoring:
    - Created DatabaseConfig class:
      • Encapsulates database-specific settings
      • Has to_dict() and setup() methods
      • Single responsibility: manage DB config
    
    - Modified AppConfig to accept manager instances:
      • Optional parameters with defaults (None)
      • Accepts injected manager instances
      • Separates concerns: AppConfig manages application settings
    
    - Used Protocol for type hints (loose coupling)
    - Extracted database-related methods to DatabaseConfig
    - Added comprehensive docstrings

Benefits:
    ✓ Loose coupling: Can inject any manager implementation
    ✓ Testable: Easy to inject mocks for unit tests
    ✓ Flexible: Can use different implementations without modifying config
    ✓ Single Responsibility: AppConfig manages settings, not object creation
    ✓ Better separation: DatabaseConfig handles DB-specific logic

Before Code Excerpt:
    class AppConfig:
        def __init__(self):
            # Direct instantiation causes tight coupling
            self.user_mgr = UserManager()
            self.data_proc = DataProcessor()
            self.calc = Calculator()
            self.db_host = 'localhost'
            # ... more config ...

After Code Excerpt:
    class AppConfig:
        def __init__(self,
                    user_manager: Optional[Manager] = None,
                    data_processor: Optional[Manager] = None,
                    calculator: Optional[Manager] = None,
                    db_config: Optional[DatabaseConfig] = None,
                    ...):
            self.user_manager = user_manager
            self.data_processor = data_processor
            self.calculator = calculator
            self.db_config = db_config or DatabaseConfig()
            # ... more config ...

================================================================================
TASK 5: REFACTOR MAIN.PY WITH EXTRACTED DEMO FUNCTIONS
================================================================================

Task: Split complex main into smaller functions and improve readability

Code Selection:
    File: main.py
    Method: main()
    Lines: Entire function mixing setup, demos, and output

Type: Extract demo logic into separate functions + Add helper for output

Before Refactoring:
    - main() was a 30-line function doing everything:
      • Creating instances
      • Running demos (UserManager, DataProcessor, Calculator)
      • Mixing console output with business logic
    
    - Print statements scattered throughout
    - Hard to test individual demos
    - Hard to reuse demo logic
    
    Problems:
    • Poor separation of concerns
    • Hard to test
    • Not reusable
    • Inconsistent output formatting

After Refactoring:
    - Created demo_* functions for each component:
      • demo_user_manager(um)
      • demo_data_processor(dp)
      • demo_calculator(calc)
      • demo_order_processing(calc)
    
    - Created print_header(title) helper:
      • Consistent formatting for section headers
      • Reusable across all demos
    
    - main() is now clear and high-level:
      • Create instances
      • Call demo functions
      • Each demo is focused and testable
    
    - Added type hints and docstrings

Benefits:
    ✓ Better separation of concerns
    ✓ Each demo function has single responsibility
    ✓ Easier to test individual components
    ✓ Consistent output formatting
    ✓ More readable and maintainable
    ✓ Reusable demo functions

Before Code Excerpt:
    def main():
        print("=== Refactoring Demo Project ===\n")
        print("1. User Manager Demo:")
        um = UserManager()
        um.add_user("John Doe", "john@example.com", 25, "password123")
        print(f"   Total users: {um.get_user_count()}")
        print(f"   Users: {um.list_users()}\n")
        # ... more demos mixed with output ...

After Code Excerpt:
    def print_header(title: str) -> None:
        print(f"\n{title}")
        print("=" * 60)
    
    def demo_user_manager(um: UserManager) -> None:
        print_header("1. User Manager Demo")
        um.add_user("John Doe", "john@example.com", 25, "password123")
        print(f"Total users: {um.get_user_count()}")
    
    def main() -> None:
        um = UserManager()
        dp = DataProcessor()
        calc = Calculator()
        
        demo_user_manager(um)
        demo_data_processor(dp)
        demo_calculator(calc)
        demo_order_processing(calc)

================================================================================
SUMMARY OF IMPROVEMENTS
================================================================================

Refactoring Metrics:
    • Code duplication eliminated: ~40 lines of repeated code removed
    • Magic numbers: 15+ magic numbers replaced with named constants
    • File size reduction: ~280 lines → ~200 lines (30% smaller)
    • Cyclomatic complexity: Reduced by splitting long methods
    • Test coverage: Smaller methods easier to test
    • Type hints: Added to all public methods
    • Documentation: Added comprehensive docstrings

Design Pattern Improvements:
    • Dependency Injection: Applied to config.py
    • Single Responsibility: Each class/method has focused purpose
    • DRY (Don't Repeat Yourself): Eliminated code duplication
    • Pythonic patterns: Used generators, comprehensions, built-in functions
    • Constants management: Centralized magic numbers
    • Validation: Extracted into separate class

Code Quality Improvements:
    • Naming: Changed from cryptic (n, e, a, p) to descriptive (name, email, age, password)
    • Error handling: divide() now raises ValueError instead of silent failure
    • Type hints: Added Optional, Dict, Iterable types
    • Docstrings: Added Args, Returns, detailed descriptions
    • Readability: Cleaner, more Pythonic code

Maintainability Improvements:
    • Constants centralized: Easy to update business rules
    • Validation centralized: Single source of truth for validation
    • Reduced coupling: Config uses dependency injection
    • Better structure: Clear separation of concerns
    • Easier testing: Smaller, focused methods

================================================================================
TEST RESULTS
================================================================================

All refactored code has been tested and runs successfully:

✓ UserManager: add_user, remove_user, get_user, update_user work correctly
✓ DataProcessor: process_numbers, process_strings, process_mixed work correctly
✓ Calculator: All arithmetic and order processing functions work correctly
✓ main.py: All demos run without errors
✓ Output: Consistent and formatted correctly

No runtime errors or functional regressions detected.

================================================================================
END OF REFACTORING SUMMARY
================================================================================
